namespace sys.core.lang;

class Slice<T: Class> {
	this(ref ppp: CArray<T>) {
		ptr = ppp.SysDataPointer;
		size = ppp.Length;
	}
	
	this(ref p: CArray<T>, length: PtrSize) {
		ptr = p.SysDataPointer;
		size = length;
	}
	
	this(ref p: CArray<T>, start: PtrSize, end: PtrSize) {
		ptr = p.SysDataPointer + start;
		size = end - start + 1;
	}
	
	this(ref p: Vector<T>) {
		ptr = p.SysDataPointer;
		size = p.Length;
	}
	
	this(ref p: Vector<T>, length: PtrSize) {
		ptr = p.SysDataPointer;
		size = length;
	}
	
	this(ref p: Small) {
		ptr = Ptr<T>{p};
		size = p.@size / T.@size;
	}
	
	this(ref p: Short) {
		ptr = Ptr<T>{p};
		size = p.@size / T.@size;
	}
	
	this(ref p: Byte) {
		ptr = Ptr<T>{p};
		size = p.@size / T.@size;
	}
	
	this(ref p: Word) {
		ptr = Ptr<T>{p};
		size = p.@size / T.@size;
	}
	
	this(ref p: Int) {
		ptr = Ptr<T>{p};
		size = p.@size / T.@size;
	}
	
	this(ref p: Int, length: PtrSize) {
		ptr = Ptr<T>{p};
		size = Intrinsic.Min(p.@size / T.@size, length);
	}
	
	this(ref p: Long) {
		ptr = Ptr<T>{p};
		size = p.@size / T.@size;
	}
	
	this(ref p: Long, length: PtrSize) {
		ptr = Ptr<T>{p};
		size = Intrinsic.Min(p.@size / T.@size, length);
	}
	
	this(ref p: DWord) {
		ptr = Ptr<T>{p};
		size = p.@size / T.@size;
	}
	
	this(ref p: DWord, length: PtrSize) {
		ptr = Ptr<T>{p};
		size = Intrinsic.Min(p.@size / T.@size, length);
	}
	
	this(ref p: QWord) {
		ptr = Ptr<T>{p};
		size = p.@size / T.@size;
	}
	
	this(ref p: QWord, length: PtrSize) {
		ptr = Ptr<T>{p};
		size = Intrinsic.Min(p.@size / T.@size, length);
	}
	
	this(ref p: Float) {
		ptr = Ptr<T>{p};
		size = p.@size / T.@size;
	}
	
	this(ref p: Float, length: PtrSize) {
		ptr = Ptr<T>{p};
		size = Intrinsic.Min(p.@size / T.@size, length);
	}
	
	this(ref p: Double) {
		ptr = Ptr<T>{p};
		size = p.@size / T.@size;
	}
	
	this(ref p: Double, length: PtrSize) {
		ptr = Ptr<T>{p};
		size = Intrinsic.Min(p.@size / T.@size, length);
	}
	
	this(ref p: String) {
		ptr = p.SysDataPointer;
		size = p.Length;
	}
	
	this(p: Slice<Byte>, length: PtrSize) {
		ptr = p.SysDataPointer;
		size = length;
	}
	
	this(p: Slice<Byte>, offset: PtrSize, length: PtrSize) {
		ptr = p.SysDataPointer + offset;
		size = length;
	}
	
	property Length: PtrSize
	get {
		return size;
	}
	set (value) {
		size = value;
	}
	
	property @index: T
	get [index: PtrSize] const {
		System.Debug.Assert(index < size);
		return ptr[index];
	}
	set (byte)[index: PtrSize] {
		System.Debug.Assert(index < size);
		ptr[index] = byte;
	}
	
	property SysDataPointer: Ptr<T>
	get {
		return ptr;
	}
	
	def Fill(value: T) {
		for (val i = 0p; i < size; i++)
			ptr[i] = value;
	}
	
	def Fill(items: Vector<T>) {
		val subIndex = 0p;
		for (val i = 0p; i < size; i++) {
			ptr[i] = items[subIndex++];
			if (subIndex >= items.Length)
				subIndex = 0p;
		}
	}
	
	def Fill(items: CArray<T>) {
		val subIndex = 0p;
		for (val i = 0p; i < size; i++) {
			ptr[i] = items[subIndex++];
			if (subIndex >= items.Length)
				subIndex = 0p;
		}
	}
	
	def FindIndex(item: T): PtrSize {
		for (val i = 0p; i < size; i++)
			if (ptr[i] == item)
				return i;
			
		return PtrSize{-1};
	}
	
	def FindIndex(item: T, start: PtrSize): PtrSize {
		val s = Intrinsic.Min(start, size - 1);
		
		for (val i = s; i < size; i++)
			if (ptr[i] == item)
				return i;
			
		return PtrSize{-1};
	}
	
	def FindIndex(b: CArray<T>): PtrSize; const {
		for (val i = 0p; i < size; i++)
			for (val j = 0p; j < b.Length; j++)
				if (ptr[i] == b[j])
					return i;
		
		return PtrSize{-1};
	}
	
	def FindIndex(b: Vector<T>): PtrSize; const {
		for (val i = 0p; i < size; i++)
			for (val j = 0p; j < b.Length; j++)
				if (ptr[i] == b[j])
					return i;
		
		return PtrSize{-1};
	}
	
	def FindIndex(b: CArray<T>, start: PtrSize): PtrSize; const {
		val s = Intrinsic.Min(start, size - 1);
		
		for (val i = s; i < size; i++)
			for (val j = 0p; j < b.Length; j++)
				if (ptr[i] == b[j])
					return i;
		
		return PtrSize{-1};
	}
	
	def FindIndex(b: Vector<T>, start: PtrSize): PtrSize; const {
		val s = Intrinsic.Min(start, size - 1);
		
		for (val i = s; i < size; i++)
			for (val j = 0p; j < b.Length; j++)
				if (ptr[i] == b[j])
					return i;
		
		return PtrSize{-1};
	}
	
	def RFindIndex(item: T): PtrSize; const {
		for (val i = size - 1; i != -1; i--)
			if (ptr[i] == item)
				return i;
		
		return PtrSize{-1};
	}
	
	def RFindIndex(item: T, val start: PtrSize): PtrSize; const {
		if (start == 0)
			start = PtrSize{-1};
		else if (start >= size)
			start = size - 1;
		
		for (val i = size - 1; i != start; i--)
			if (ptr[i] == item)
				return i;
		
		return PtrSize{-1};
	}
	
	def RFindIndex(b: CArray<T>): PtrSize; const {
		for (val i = size - 1; i != -1; i--)
			for (val j = 0p; j < b.Length; j++)
				if (ptr[i] == b[j])
					return i;
		
		return PtrSize{-1};
	}
	
	def RFindIndex(b: Vector<T>): PtrSize; const {
		for (val i = size - 1; i != -1; i--)
			for (val j = 0p; j < b.Length; j++)
				if (ptr[i] == b[j])
					return i;
		
		return PtrSize{-1};
	}
	
	def RFindIndex(b: CArray<T>, val start: PtrSize): PtrSize; const {
		if (start == 0)
			start = PtrSize{-1};
		else if (start >= size)
			start = size - 1;
		
		for (val i = size - 1; i != start; i--)
			for (val j = 0p; j < b.Length; j++)
				if (ptr[i] == b[j])
					return i;
		
		return PtrSize{-1};
	}
	
	def RFindIndex(b: Vector<T>, val start: PtrSize): PtrSize; const {
		if (start == 0)
			start = PtrSize{-1};
		else if (start >= size)
			start = size - 1;
		
		for (val i = size - 1; i != start; i--)
			for (val j = 0p; j < b.Length; j++)
				if (ptr[i] == b[j])
					return i;
		
		return PtrSize{-1};
	}
	
	def BinaryIndex(item: T): PtrSize {
		val lowerBound = 0p;
		val upperBound = size - 1;
		
		while(lowerBound <= upperBound) {
			val midPoint = lowerBound + (upperBound - lowerBound) / 2;
		
			if(ptr[midPoint] == item)
				return midPoint;
			else if(ptr[midPoint] < item)
				lowerBound = midPoint + 1;
			else
				upperBound = midPoint -1;
		}
		
		return PtrSize{-1};
	}
	
	def Reverse() {
		val upperBound = size - 1;
		val mid = upperBound / 2;
		
		for (val i = 0p; i <= mid; i++)
			Swap(ptr[i], ptr[upperBound - i]);
	}
	
	def Delete(item: T): PtrSize {
		val index = FindIndex(item);
		
		if (index == -1)
			return 0;
		
		ptr[index].~{};
		
		for (val i = index; i < size - 1; i++)
			ptr[i]{move(ptr[i+ 1])};
		
		size--;
		return 1p;
	}
	
	def Delete(items: CArray<T>): PtrSize {
		val count = 0p;
		
		foreach (v in items)
			count += Delete(v);
			
		return count;
	}
	
	def Delete(items: Vector<T>): PtrSize {
		val count = 0p;
		
		foreach (v in items)
			count += Delete(v);
			
		return count;
	}
		
	def DeleteAll(item: T): PtrSize {
		val count = 0p;
		while (true) {
			val index = FindIndex(item);
			
			if (index == -1)
				return count;
			
			ptr[index].~{};
			
			for (val i = index; i < size - 1; i++)
				ptr[i]{move(ptr[i+ 1])};
			
			size--;
			count++;
		}
		
		return count;
	}
	
	def DeleteAll(items: CArray<T>): PtrSize {
		val count = 0p;
		
		foreach (v in items)
			count += DeleteAll(v);
		
		return count;
	}
	
	def DeleteAll(items: Vector<T>): PtrSize {
		val count = 0p;
		
		foreach (v in items)
			count += DeleteAll(v);
			
		return count;
	}
	
	def Insert(pos: PtrSize, item: T) {
		for (val i = size; i >= pos + 1; i--)
			ptr[i]{move(ptr[i - 1])};
		
		ptr[pos] = item;
		
		size++;
	}
	
	def Insert(pos: PtrSize, items: CArray<T>) {
		foreach (v, i in items)
			Insert(pos + i, v);
	}
	
	def Insert(pos: PtrSize, items: Vector<T>) {
		foreach (v, i in items)
			Insert(pos + i, v);
	}
	
	def Sort(val low: PtrSize, val high: PtrSize) {
		while (true) {
			val count = Int{high - low};
			if(count < 2)
				return;
			
			val pass = 4;
			
			while (true) {
				val middle = low + (count >> 1);
				
				Order(low, middle);
				Order(middle, high - 1);
				Order(low, middle);

				IterSwap(low + 1, middle);
				
				val ii = low + 1;
				for (val i = low + 2; i < high - 1; i++)
					if(ptr[i] < ptr[low + 1]) {
						ii++;
						IterSwap(ii, i);
					}
				
				IterSwap(ii, low + 1);
				
				val iih = ii;
				while (iih + 1 != high && ptr[ii] >= ptr[iih + 1])
					iih++;
				
				if (pass > 5 || Intrinsic.Min(ii - low, high - iih) > (Intrinsic.Max(ii - low, high - iih) >> pass)) {
					if (ii - low < high - iih - 1) {
						Sort(low, ii);
						low = iih + 1;
					}
					else {
						Sort(iih + 1, high);
						high = ii;
					}
					break;
				}
				
				IterSwap(low, low + (count >> 1));
				IterSwap(middle, low + (count >> 1));
				IterSwap(high - 1, low + (count >> 1));
				
				pass++;
			}
		}
	}
	
	def Sort() {
		Sort(0p, size);
	}
}
private {
	val ptr: Ptr<T>;
	val size: PtrSize;
	
	static def Swap(ref f: T, ref s: T) {
		val temp = f;
		f = s;
		s = temp;
	}
	
	def IterSwap(l: PtrSize, h: PtrSize) {
		if (l != h)
			Swap(ptr[l], ptr[h]);
	}
	
	def Order(l: PtrSize, h: PtrSize) {
		if (ptr[h] < ptr[l])
			Swap(ptr[l], ptr[h]);
	}
}